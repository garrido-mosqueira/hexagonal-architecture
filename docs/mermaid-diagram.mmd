sequenceDiagram
    actor Client
    participant UC as TaskUseCase (TaskService)
    participant TM as TaskManagerAdapter
    participant TS as ThreadingStrategy (Specific Impl)
    participant Redis
    participant Worker as Worker Thread (runLoop)
    participant DB as MongoDB

    note over Client, Redis: ðŸš€ Part 1: Task Execution Kickoff

    Client->>UC: executeTask(taskId)
    note right of UC: Includes input validation via DTO
    activate UC
    UC->>TM: executeTask(task)
    activate TM
    TM->>Redis: GET task:register:{id}
    Redis-->>TM: check if already running
    alt Not Running
        TM->>TM: Determine Strategy based on TaskType
        TM->>TS: launch(taskId, runLoopLambda)
        activate TS
        TS--)Worker: Async Start (e.g., threadPool.submit(runLoopLambda))
        deactivate TS
    end
    TM-->>UC: return task
    deactivate TM
    UC-->>Client: return (202 Accepted)
    deactivate UC

    note over Redis, Worker: ðŸ”„ Part 2: The Async Execution Loop

    activate Worker
    note right of Worker: runLoop starts here
    Worker->>Redis: SET task:register:{id} <br/>Value: TaskThread(task, isCancelled=false)
    Worker->>DB: Update task status to RUNNING
    
    loop While (i <= finish) AND (not cancelled)
        Worker->>Worker: Increment progress (i++)
        Worker->>Redis: SET task:register:{id} <br/>Value: TaskThread(updatedTask, false)
        note right of Worker: Simulate work
        Worker->>Worker: Thread.sleep(1000)

        rect rgb(240, 240, 240)
            note right of Worker: Crucial Step: Polling for cancellation signal
            Worker->>Redis: GET task:register:{id}
            Redis-->>Worker: Returns current TaskThread
            Worker->>Worker: Check if TaskThread.isCancelled()
        end
    end

    note right of Worker: Loop finished normally OR loop broken via cancellation
    alt isCancelled
        Worker->>DB: Update final task status to CANCELLED
    else Completed
        Worker->>DB: Update final task status to COMPLETED
    end
    Worker->>Redis: DEL task:register:{id}
    note right of Worker: Task Complete


    note over Client, Worker: ðŸ›‘ Part 3: Intervening Cancellation Scenario

    note right of Client: Assume Worker is currently running in the "loop" above
    Client->>UC: cancelTask(taskId)
    activate UC
    UC->>TM: cancelTask(taskId)
    activate TM
    TM->>Redis: GET task:register:{id}
    Redis-->>TM: Value: TaskThread(task, isCancelled=false)
    
    alt Task Running and Not Cancelled
        rect rgb(255, 230, 230)
            note right of TM: The "Kill Signal". <br/>Does NOT stop thread immediately.<br/>Just updates shared state.
            TM->>Redis: SET task:register:{id} <br/>Value: TaskThread(task, isCancelled=TRUE)
        end
    else Not running / Already cancelled
        TM->>TM: Log: Already cancelled or not running
    end
    deactivate TM
    UC-->>Client: return (200 OK)
    deactivate UC

    activate Worker
    note right of Worker: Back in the Worker Thread loop...
    Worker->>Worker: Wakes up from sleep
    Worker->>Redis: GET task:register:{id}
    Redis-->>Worker: Value: TaskThread(task, isCancelled=TRUE)
    Worker->>Worker: Detects isCancelled=true. Breaks loop.
    Worker->>Redis: DEL task:register:{id}
    deactivate Worker